<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1.0, user-scalable=no" />
  <title>かけ算筆算ステップ｜スマホ最適化（直接入力版 v0.8.3）</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=BIZ+UDPGothic:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root{ --cell:96px }
    *{ box-sizing:border-box }
    body{
      font-family:'BIZ UDPGothic', system-ui, -apple-system, 'Hiragino Sans', 'Noto Sans CJK JP', Meiryo, sans-serif;
      background:#f4f7fb; margin:0; display:flex; flex-direction:column; align-items:center; gap:14px; padding:16px;
      touch-action:none;
    }
    h2{ margin:0; color:#0f172a; font-size:clamp(20px, 3.8vw, 28px) }

    /* ── 右固定ツールバー（縦並び） ── */
    .toolbar{ position:fixed; right: max(env(safe-area-inset-right), 10px); top: clamp(64px, 8vh, 96px); display:flex; flex-direction:column; gap:8px; background:transparent; padding:0; border:none; box-shadow:none; z-index:40 }
    .toolbar button{ width:112px; padding:10px 12px; font-size:16px; border:none; border-radius:10px; cursor:pointer; font-weight:700 }
    #stepButton{ background:#0f172a; color:#fff }
    #undoButton{ background:#334155; color:#fff }
    #drawButton{ background:#64748b; color:#fff }
    #drawButton.active{ background:#dc3545; box-shadow:0 0 0 3px rgba(220,53,69,.15) }
    #clearButton{ background:#fcd34d; color:#111 }
    #resetButton{ background:#e2e8f0; color:#111 }

    /* 盤面 */
    #calculator-wrapper{ position:relative; max-width:100vw; overflow:hidden }
    #hissan-display{ display:grid; grid-template-columns:repeat(4, var(--cell)); grid-auto-rows:auto; gap:0; background:#fff; border:2px solid #0f172a; border-radius:12px; padding:10px; box-shadow:0 10px 30px rgba(0,0,0,.08) }

    .cell{ width:var(--cell); height:var(--cell); border:1px solid #e2e8f0; display:flex; align-items:center; justify-content:center; font-size:clamp(24px, calc(var(--cell)*0.44), 56px); color:#0f172a; position:relative; transition:background-color .15s }
    .cell.empty{ border:none }
    .cell.calculating{ background:#fff8c4; border-color:#f7d777 }

    .cell.tap-target{ cursor:pointer }

    /* かける記号 */
    .cell.op{ border:none; font-size:clamp(22px, calc(var(--cell)*0.38), 40px); font-weight:700; color:#475569; pointer-events:none }

    /* 繰り上がり（上1/3帯） */
    .cell .carry{ position:absolute; inset:0 0 auto 0; height:33%; border-bottom:2px dashed #e2e8f0; display:flex; align-items:center; justify-content:center; font-size:clamp(12px, calc(var(--cell)*0.22), 28px); font-weight:700; color:#475569; pointer-events:none }
    .cell.carry-row{ height: calc(var(--cell) / 3); border:none }
    .cell.carry-row .carry{ position:static; height:100%; border-bottom:none }

    /* 区切り線 */
    .line{ grid-column:1 / -1; height:2px; background:#0f172a; border:none; margin:6px 0 }

    /* 色分けテーマ（p1=青, p2=緑, p3=橙） */
    .p1-digit{ color:#2563eb; font-weight:700 }
    .p1-carry{ color:#3b82f6 }
    .p2-digit{ color:#059669; font-weight:700 }
    .p2-carry{ color:#10b981 }
    .p3-digit{ color:#f59e0b; font-weight:700 }
    .p3-carry{ color:#fbbf24 }
    .ans-digit{ color:#0f172a; font-weight:800 }
    .sum-carry{ color:#7c3aed; font-weight:700 }
    .sum-overlay{ border-bottom:none }

    /* 手書きレイヤー */
    #drawingCanvas{ position:absolute; inset:0; pointer-events:none; touch-action:none }

    /* ── ボトムキーパッド（スマホ向け） ── */
    #keypad{ position:fixed; left:0; right:0; bottom:0; transform:translateY(100%); transition:transform .2s ease; z-index:30 }
    #keypad.show{ transform:translateY(0) }
    .kp-inner{ background:#111827; color:#fff; border-top-left-radius:16px; border-top-right-radius:16px; padding:12px 12px 16px; box-shadow:0 -12px 32px rgba(0,0,0,.35) }
    .kp-title{ font-size:14px; opacity:.85; margin-bottom:4px }
    .kp-display{ font-size:24px; letter-spacing:3px; background:#fff; color:#111; padding:10px 12px; border-radius:10px; text-align:right; margin-bottom:8px; border:1px solid #e5e7eb }
    .kp-grid{ display:grid; grid-template-columns:repeat(3, 1fr); gap:8px }
    .kp-btn{ background:#374151; color:#fff; border:none; border-radius:12px; padding:14px 0; font-size:22px; font-weight:800 }
    .kp-btn.mul{ background:#f59e0b; color:#111 }
    .kp-btn.wide{ grid-column: span 2 }
    .kp-btn.ok{ background:#10b981 }
    .kp-btn.fn{ background:#4b5563 }

    @media (max-width: 600px){ .toolbar{ padding:6px 8px } .toolbar button{ padding:8px 10px; font-size:15px } }
  </style>
</head>
<body>
  <h2>かけ算の筆算（マスをタップして始める）</h2>
  <div class="toolbar">
    <button id="stepButton">▶️ つぎへ</button>
    <button id="undoButton">⏮ もどす</button>
    <button id="drawButton">✏️ かく</button>
    <button id="clearButton">けす</button>
    <button id="resetButton">リセット</button>
  </div>

  <div id="calculator-wrapper">
    <div id="hissan-display"></div>
    <canvas id="drawingCanvas"></canvas>
  </div>

  <!-- 問題入力用ボトムキーパッド（式モード） -->
  <div id="keypad">
    <div class="kp-inner">
      <div class="kp-title" id="kp-title">問題を入力（例：345✖️98）</div>
      <div class="kp-display" id="kp-display"></div>
      <div class="kp-grid">
        <button class="kp-btn">1</button>
        <button class="kp-btn">2</button>
        <button class="kp-btn">3</button>
        <button class="kp-btn">4</button>
        <button class="kp-btn">5</button>
        <button class="kp-btn">6</button>
        <button class="kp-btn">7</button>
        <button class="kp-btn">8</button>
        <button class="kp-btn">9</button>
        <button class="kp-btn mul">×</button>
        <button class="kp-btn">0</button>
        <button class="kp-btn fn">⌫</button>
        <button class="kp-btn wide fn">C</button>
        <button class="kp-btn wide ok">計算</button>
        <button class="kp-btn wide fn" id="kp-cancel">キャンセル</button>
      </div>
    </div>
  </div>

  <script>
    // ========= ユーティリティ =========
    const el = (s) => document.querySelector(s);
    const els = (s) => Array.from(document.querySelectorAll(s));
    const make = (tag, cls) => { const x=document.createElement(tag); if(cls) x.className=cls; return x };
    const clamp = (x, lo, hi) => Math.max(lo, Math.min(hi, x|0));

    // Unicodeセーフな1文字削除
    const backspaceOne = (str) => { const a = Array.from(str||''); a.pop(); return a.join('') };

    // ========= 現在の問題（初期は空欄） =========
    let curN1 = null; // 1..9999
    let curN2 = null; // 1..999

    // ========= 盤面状態 =========
    let cols = 4;
    let len1 = 0, len2 = 0;
    let stepList = [];
    let stepIndex = -1;
    let workCarry = 0;

    // ========= 手書き =========
    const canvas = el('#drawingCanvas'); const ctx = canvas.getContext('2d');
    const hissan = el('#hissan-display');
    let isDrawingMode=false, isDrawing=false;

    function resizeCanvas(){ try{ autoFitCell(); }catch(e){} canvas.width = hissan.offsetWidth; canvas.height = hissan.offsetHeight; ctx.strokeStyle='rgba(255,0,0,.7)'; ctx.lineWidth=3; ctx.lineCap='round'; ctx.lineJoin='round'; }
    window.addEventListener('load', () => { buildBoard(curN1, curN2); autoFitCell(); resizeCanvas(); });
    window.addEventListener('resize', () => { autoFitCell(); resizeCanvas(); });
    window.addEventListener('orientationchange', () => setTimeout(() => { autoFitCell(); resizeCanvas(); }, 200));

    el('#drawButton').addEventListener('click', () => { isDrawingMode=!isDrawingMode; el('#drawButton').classList.toggle('active', isDrawingMode); canvas.style.pointerEvents = isDrawingMode? 'auto':'none'; });
    el('#clearButton').addEventListener('click', () => ctx.clearRect(0,0,canvas.width,canvas.height));

    ['mousedown','mousemove','mouseup','mouseout'].forEach((ev) => canvas.addEventListener(ev, eMouse, {passive:false}));
    ['touchstart','touchmove','touchend','touchcancel'].forEach((ev) => canvas.addEventListener(ev, eTouch, {passive:false}));
    function eMouse(e){ if(!isDrawingMode) return; if(e.type==='mousedown'){ isDrawing=true; const [x,y]=coords(e); ctx.beginPath(); ctx.moveTo(x,y); } else if(e.type==='mousemove'){ if(!isDrawing) return; e.preventDefault(); const [x,y]=coords(e); ctx.lineTo(x,y); ctx.stroke(); } else { if(!isDrawing) return; ctx.closePath(); isDrawing=false; } }
    function eTouch(e){ if(!isDrawingMode) return; const t=e.type; if(t==='touchstart'){ isDrawing=true; const [x,y]=coords(e); ctx.beginPath(); ctx.moveTo(x,y); } else if(t==='touchmove'){ if(!isDrawing) return; e.preventDefault(); const [x,y]=coords(e); ctx.lineTo(x,y); ctx.stroke(); } else { if(!isDrawing) return; ctx.closePath(); isDrawing=false; } }
    function coords(e){ const r=canvas.getBoundingClientRect(); let x,y; if(e.touches){ x=e.touches[0].clientX-r.left; y=e.touches[0].clientY-r.top; } else { x=e.clientX-r.left; y=e.clientY-r.top; } return [x,y]; }

    // ========= 自動フィット =========
    function autoFitCell(){
      const vw = Math.min(window.innerWidth || 0, document.documentElement.clientWidth || 0) || window.innerWidth;
      const vh = Math.min(window.innerHeight || 0, document.documentElement.clientHeight || 0) || window.innerHeight;
      const toolbarH = document.querySelector('.toolbar')?.getBoundingClientRect().height || 0;

      const availW = Math.max(200, vw - 24);
      const availH = Math.max(200, vh - toolbarH - 24);
      const units = 4*len2 + 10;
      let cellGuess = Math.min(120, Math.floor(availW/Math.max(1,cols)), Math.floor(3*availH/Math.max(1,units)));
      if(!cellGuess || cellGuess<32) cellGuess=32;
      document.documentElement.style.setProperty('--cell', cellGuess+'px');
      let guard=30;
      while(guard-- > 0){ const r=hissan.getBoundingClientRect(); if(r.width<=availW && r.height<=availH) break; const now=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'))||cellGuess; const next=Math.max(32, Math.floor(now*0.92)); if(next===now) break; document.documentElement.style.setProperty('--cell', next+'px'); }
    }

    // ========= 汎用関数 =========
    function rightDigits(n, count){ const arr=String(n).split('').map(Number); const out=new Array(count).fill(null); for(let i=0;i<arr.length;i++) out[count-1-i]=arr[arr.length-1-i]; return out }
    function setText(id, v){ const e=document.getElementById(id); if(e) e.textContent=(v===null||v===undefined)?'':String(v) }
    function getText(id){ const e=document.getElementById(id); return e? e.textContent: '' }

    // ========= 盤生成 =========
    let idsAll=[];
    function buildBoard(n1, n2){
      // n1, n2 が未設定なら空欄で 2桁×2桁想定の盤を出す
      len1 = Number.isInteger(n1) ? String(n1).length : 0;
      len2 = Number.isInteger(n2) ? String(n2).length : 0;
      const baseL1 = len1 || 2, baseL2 = len2 || 2;
      cols = Math.max(4, baseL1 + baseL2);

      hissan.style.gridTemplateColumns = `repeat(${cols}, var(--cell))`;
      hissan.innerHTML=''; idsAll=[];

      // n1行（タップ可能）
      appendDigitRow('n1-c', '', cols, true);
      // n2行（タップ可能）
      appendDigitRow('n2-c', '', cols, true);

      appendLine();
      // 部分積行（len2本。未設定時は 2 行を仮置き）
      const pp = (len2===0 ? 2 : (len2===1 ? 1 : len2));
      for(let r=0;r<pp;r++){ const theme = r===0?'p1':r===1?'p2':'p3'; appendCarryRow(`c_p${r+1}-c`, `${theme}-carry`, cols); appendDigitRow(`p${r+1}-c`, `${theme}-digit`, cols); }
      if(len2>1){
        appendLine();
        // 足し算の繰り上がり行 + 答え
        appendCarryRow('c_sum-c','sum-carry',cols);
        appendDigitRow('ans-c','ans-digit',cols);
      }

      // 値をセット（数値のときのみ）
      if(len1>0) rightDigits(n1, cols).forEach((v,i)=> setText(`n1-c${i}`, v??''));
      if(len2>0) rightDigits(n2, cols).forEach((v,i)=> setText(`n2-c${i}`, v??''));

      // × 記号は必ず最後に描画（数字で上書きされないように）
      placeOperator();

      // セルタップ→キーパッド（上2行のみ）
      enableTapToEdit();

      autoFitCell(); resizeCanvas();
    }
    function appendDigitRow(prefix, rowClass, count, tappable=false){ for(let i=0;i<count;i++){ const c=make('div',`cell ${rowClass} ${tappable?'tap-target':''}`); c.id=`${prefix}${i}`; hissan.appendChild(c); idsAll.push(c.id); } }
    function appendCarryRow(prefix, rowClass, count){ for(let i=0;i<count;i++){ const c=make('div','cell carry-row'); const car=make('div',`carry ${rowClass}`); car.id=`${prefix}${i}`; c.appendChild(car); hissan.appendChild(c); idsAll.push(car.id); } }
    function appendLine(){ const line = make('div','line'); hissan.appendChild(line); }

    // かける記号の配置を一元化
    function placeOperator(){
      // ルール：より桁数の“長い”数の直前（1マス左）に×を置く
      const L1 = len1 || 2;
      const L2 = len2 || 2;
      const longer = Math.max(L1, L2);
      const opIndex = Math.max(0, cols - longer - 1);
      const opCell = document.getElementById(`n2-c${opIndex}`);
      if(opCell){ opCell.classList.add('op'); opCell.textContent='×'; }
    }

    // ========= ステップ構築・実行 =========
    let history=[];
    function initProblem(){
      if(!Number.isInteger(curN1) || !Number.isInteger(curN2)) { openKeypad(); return; }
      buildBoard(curN1, curN2);
      stepList=[]; history=[]; stepIndex=-1; workCarry=0;
      // 部分積（len2 行）
      for(let r=0;r<len2;r++){
        for(let k=0;k<len1;k++){
          const srcCol = cols-1-k;
          const tgtCol = srcCol - r;
          const bIndex = cols-1-r;
          stepList.push({kind:'hl', ids:[`n2-c${bIndex}`, `n1-c${srcCol}`]});
          stepList.push({kind:'p', row:r, srcCol, col:tgtCol});
        }
        const carryCol = (cols-1-len1) - r;
        stepList.push({kind:'p_carryOut', row:r, col:carryCol});
      }
      if(len2>1){
        // 加算
        for(let c=cols-1;c>=0;c--){ const ids=[]; for(let r=0;r<len2;r++) ids.push(`p${r+1}-c${c}`); stepList.push({kind:'hl', ids}); stepList.push({kind:'sum', col:c, rows:len2}); }
      }
      stepList.push({kind:'done'});
    }

    function doStep(){
      if(stepIndex===-1){ initProblem(); if(stepList.length===0) return; stepIndex=0; applyStep(stepList[0]); return; }
      if(stepIndex>=stepList.length-1){ resetAll(); return; }
      pushSnapshot(); stepIndex++; applyStep(stepList[stepIndex]);
    }
    function applyStep(s){ if(!s) return; switch(s.kind){ case 'hl': highlightIds(s.ids); break; case 'p': doPartial(s.row, s.srcCol, s.col); break; case 'p_carryOut': writeFinalCarry(s.row, s.col); break; case 'sum': doSum(s.col, s.rows); break; case 'done': clearHighlights(); trimAnswerLeadingZeros(); el('#stepButton').textContent='リセット'; break; } }
    function highlightIds(ids){ clearHighlights(); ids.forEach((id)=>{ const e=document.getElementById(id); if(e) e.classList.add('calculating'); }); }
    function clearHighlights(){ hissan.querySelectorAll('.cell.calculating').forEach((e)=> e.classList.remove('calculating')); }

    function pushSnapshot(){ const snap={ stepIndex, workCarry, texts:{}, hl:[], stepBtn:el('#stepButton').textContent }; idsAll.forEach((id)=> snap.texts[id]=getText(id)); snap.hl=[...hissan.querySelectorAll('.cell.calculating')].map((e)=>e.id).filter(Boolean); history.push(JSON.stringify(snap)); el('#undoButton').disabled = history.length===0; }
    function undo(){ const raw=history.pop(); if(!raw) return; const s=JSON.parse(raw); stepIndex=s.stepIndex; workCarry=s.workCarry; idsAll.forEach((id)=> setText(id,s.texts[id])); clearHighlights(); s.hl.forEach((id)=>{ const e=document.getElementById(id); if(e) e.classList.add('calculating'); }); el('#stepButton').textContent=s.stepBtn; el('#undoButton').disabled = history.length===0; }

    function multiplierDigit(row){ return Number(getText(`n2-c${cols-1-row}`)||0); }
    function doPartial(row, srcCol, col){ if(srcCol<0) return; const a=Number(getText(`n1-c${srcCol}`)||0); const b=multiplierDigit(row); const prod=a*b+workCarry; const d=prod%10; workCarry=Math.floor(prod/10); if(col>=0) setText(`p${row+1}-c${col}`, d); if(col-1>=0) setText(`c_p${row+1}-c${col-1}`, workCarry>0?workCarry:''); }
    function writeFinalCarry(row,col){ if(workCarry<=0) return; if(col>=0) setText(`p${row+1}-c${col}`, workCarry); workCarry=0; }

    function doSum(col, rows){
      let s = workCarry;
      for(let r=0;r<rows;r++) s += Number(getText(`p${r+1}-c${col}`)||0);
      const d = s % 10;
      workCarry = Math.floor(s / 10);
      setText(`ans-c${col}`, d);
      if(col-1>=0) setText(`c_sum-c${col-1}`, workCarry>0 ? workCarry : '');
    }

    function trimAnswerLeadingZeros(){ let started=false; for(let i=0;i<cols;i++){ const id=`ans-c${i}`; const v=getText(id); if(!started){ if(v===''||v==='0'){ setText(id,''); continue; } started=true; } } }

    function resetAll(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // 描画モードも解除
      isDrawingMode=false; el('#drawButton').classList.remove('active'); canvas.style.pointerEvents='none';
      buildBoard(curN1, curN2);
      stepList=[]; stepIndex=-1; workCarry=0; history.length=0; clearHighlights();
      el('#stepButton').textContent='▶️ つぎへ'; el('#undoButton').disabled=true;
    }

    // ========= 直接入力：マスをタップ→式キーパッド =========
    let kpValue='';
    function enableTapToEdit(){
      els('[id^="n1-c"].cell').forEach((c)=> c.addEventListener('click', openKeypad));
      els('[id^="n2-c"].cell').forEach((c)=> c.addEventListener('click', openKeypad));
    }

    // 画面のどこをタップしてもキーパッド（ツールバー/キーパッド/描画中は除く）
    document.addEventListener('click', (e)=>{
      if(isDrawingMode) return;
      if(e.target.closest('.toolbar') || e.target.closest('#keypad')) return;
      openKeypad();
    });

    function openKeypad(){
      kpValue = (Number.isInteger(curN1) && Number.isInteger(curN2)) ? `${curN1}✖️${curN2}` : '';
      el('#kp-title').textContent='問題を入力（例：345✖️98）';
      el('#kp-display').textContent=kpValue;
      el('#keypad').classList.add('show');
    }
    function closeKeypad(){ el('#keypad').classList.remove('show'); }

    // キーパッド動作（式モード）
    el('#keypad').addEventListener('click', (e) => {
      const b = e.target.closest('.kp-btn');
      if(!b) return;
      const t = b.textContent.trim();

      if(t==='計算'){
        const normalized = kpValue.replace(/️/g,'').replace(/[xX×*✖]/,'×');
        const parsed = parseExpr(normalized);
        if(!parsed){ shakeDisplay(); return; }
        const [a,bn] = parsed;
        // 範囲チェック
        if(a<1 || a>9999 || bn<1 || bn>999){ shakeDisplay(); return; }
        curN1 = a; curN2 = bn;
        resetAll(); // 盤面に即反映
        closeKeypad();
        return;
      }
      if(t==='キャンセル'){
        closeKeypad();
        return;
      }
      if(t==='C'){
        kpValue=''; el('#kp-display').textContent='';
        return;
      }
      if(t==='⌫'){
        kpValue = backspaceOne(kpValue);
        el('#kp-display').textContent = kpValue;
        return;
      }
      if(/[xX×✖]/.test(t)){
        if(!kpValue || /[xX×*✖]/.test(kpValue)) return; // 先頭や重複禁止
        kpValue += '×';
        el('#kp-display').textContent = kpValue;
        return;
      }
      // 数字
      if(/^[0-9]$/.test(t)){
        const m = kpValue.match(/[xX×*✖]/);
        if(!m){
          // 左辺（最大4桁）
          const leftLen = (kpValue.match(/\d/g)||[]).length;
          if(leftLen>=4) return;
          kpValue += t;
        }else{
          // 右辺（最大3桁）
          const idx = m.index + m[0].length;
          const right = kpValue.slice(idx);
          const rightLen = (right.match(/\d/g)||[]).length;
          if(rightLen>=3) return;
          kpValue += t;
        }
        el('#kp-display').textContent = kpValue;
        return;
      }
    });

    function parseExpr(expr){
      const s = String(expr||'').replace(/\s+/g,'');
      if(!s) return null;
      const m = s.match(/[xX×*✖]/);
      if(!m) return null;
      const a = s.slice(0, m.index);
      const b = s.slice(m.index + m[0].length);
      if(!a || !b) return null;
      const ai = parseInt(a,10), bi = parseInt(b,10);
      if(!Number.isFinite(ai) || !Number.isFinite(bi)) return null;
      return [ai, bi];
    }

    function shakeDisplay(){ const d=el('#kp-display'); d.style.transform='translateX(0)'; d.animate([{transform:'translateX(0)'},{transform:'translateX(-8px)'},{transform:'translateX(8px)'},{transform:'translateX(0)'}],{duration:180}); }

    el('#kp-cancel').addEventListener('click', () => { closeKeypad(); });

    // ========= イベント =========
    el('#stepButton').addEventListener('click', doStep);
    el('#undoButton').addEventListener('click', undo);
    el('#resetButton').addEventListener('click', resetAll);

    // ========= 簡易テスト（コンソール出力） =========
    function readAnswer(){
      // ans 行がない（len2==1 など）場合は p1 行を読む
      const hasAns = !!document.getElementById('ans-c0');
      if(!hasAns || len2===1){
        let s=''; for(let i=0;i<cols;i++){ const v=getText(`p1-c${i}`); s += (v && v!=='' ? v : ''); }
        return s===''? '0' : s;
      }
      let s=''; for(let i=0;i<cols;i++){ const v = getText(`ans-c${i}`); s += (v && v!=='' ? v : ''); } return s===''? '0' : s;
    }
    function runOneCase(a,b){ curN1=a; curN2=b; initProblem(); for(let i=0;i<stepList.length;i++) applyStep(stepList[i]); const got = parseInt(readAnswer(),10); const expect = a*b; const ok = got===expect; console.log(`[TEST] ${a}×${b} => got:${got} expect:${expect} ${ok?'✅':'❌'}`); return ok }
    function runSelfTests(){ const cases = [[12,3],[7,8],[34,27],[123,4],[105,12],[12,307],[9999,999],[34,72],[500,500],[101,101],[2003,7],[9999,1],[9012,345],[1,999],[10,10],[2500,40],[88,250],[999,500],[4321,999],[1000,999],[808,101]]; let pass=true; cases.forEach(([a,b])=>{ pass = runOneCase(a,b) && pass }); console.log(`SelfTests: ${pass?'ALL PASS ✅':'SOME FAIL ❌'}`);
      // UIテスト：かける記号が残っているか
      curN1=34; curN2=27; buildBoard(curN1, curN2); const L1=len1||2, L2=len2||2; const idx=Math.max(0, cols-Math.max(L1,L2)-1); const op=(document.getElementById(`n2-c${idx}`)?.textContent||''); console.log(`[UI] operator visible: ${/×/.test(op)?'OK':'MISSING'}`);
      // パーサテスト（×/✖️/x/*）
      const exprs=['345×98','345✖️98','345x98','345*98'];
      exprs.forEach(s=>{ const norm=s.replace(/️/g,'').replace(/[xX×*✖]/,'×'); const p=parseExpr(norm); console.log(`[PARSE] '${s}' => ${p?p.join(','):'ERR'}`); });
      // 初期表示は空欄に戻す
      curN1=null; curN2=null; resetAll(); }

    // 初期盤（空欄）を描画し、自己テストはバックグラウンドで実行
    setTimeout(runSelfTests, 0);
  </script>
</body>
</html>
